======================
Compilation feature
======================

.. warning:: This feature is work in progress, and content of this page will change over next month. Only about 1/4 is implemented at this point. Please check .compile() but do not be dissapointed if you see NotImplementedError. Enjoy.


Overall
=========

Construct 2.9 adds an experimental feature: compiling user made constructs into faster (but less feature-rich) code. If you are familiar with Kaitai Struct, an alternative framework to Construct, Kaitai compiles yaml-based schemas into Python modules. Construct on the other hand, defines schemas in Python and compiles them into also Python modules. Once you define a construct, you can use it to parse and build strings without compilation. Compilation has only one purpose: performance. Compiled constructs cannot do anything more than original constructs, in fact, they have restricted capabilities (some classes do not compile, or compile only under certain circumstances).


Requirements
---------------

Compilation feature requires Construct 2.9 and Python 3.4. More importantly, you should manually inspect the generated code for correctness and have a test suite of your own. Construct aims to be reliable, but the compiler makes some assumptions, and generates a code that "takes shortcuts".


Restrictions
---------------

.. warning:: These items are being implemented. Most items will be removed within next month.

Compiled classes only parse faster, building and sizeof defers to core classes

AssertionError and standard hierarchy exceptions can be raised (core classes are resticted to ConstructError and its derivatives)

RepeatUntil Enum FlagsEnum StopIf Pointer Peek Select Optional Switch Checksum Compressed are not yet implemented

.. warning:: These items are (probably) permanent, but feel free to request changes.

Lambdas (unlike `this` expressions) are not compilable

Global string encoding is applied during compilation (not during parsing and building)

Sizeof is applied during compilation (not during parsing and building)

Some classes require fixed-sized subcons (otherwise raise NotImplementedError if compiled)

Some classes require constant selectors like FocusedSeq Union (otherwise raise NotImplementedError if compiled)

Exceptions do not include `path` information

Adapters and validators, and mappings are in general not compilable

Restreamed Rebuffered are in general not compilable (except Bitwise Bytewise BytesSwapped BitsSwapped)

Lazy* OnDemand are not compilable


Compiling schemas
===================

Every construct (even those that do not compile) has a parameter-less `compile` method that returns also a construct (instance of Compiled class). Note that compiling takes a substantial amount of time (compared to parsing a single blob) so it may be a good idea to compile something that is used for processing giga-sized data or multiple blobs of data, but should not be overused.
That compiled instance has `parse` and `build` methods like any other class.

>>> st = Struct("num" / Byte)
>>> st.parse(b"\x01")
Container(num=1)
>>> st2 = st.compile()
>>> st2.parse(b"\x01")
Container(num=1)

Compiled instance has a unique `source` field that holds the generated code as string and also has a unique method `tofile` that saves the generated source code to a file, for your inspection for example. You can also import such a module from a Python script.

>>> st2.source
"... schema code ..."
>>> st2.tofile("schema1.py")
>>> import schema1

Performance boost can be easily measured: 

>>> print(st.benchmark(sampledata))
Timeit measurements:
compiling:         0.00452083740001398872 sec/call
parsing:           0.00062362513400148595 sec/call
parsing compiled:  0.00030551492700033121 sec/call
building:          0.00068562510999981897 sec/call
building compiled: 0.00068885248700098598 sec/call

Correctness can be automatically tested:

>>> st.testcompiled(sampledata)


Motivation
============

The code generated by compiler and core classes have essentially same functionality, but there is a noticable difference in performance. This chapter explains the difference by comparing `Struct FormatField BytesInteger Bytes` classes, including using a context. Example construct:

::

    Struct(
        "num8" / Int8ub,
        "num24" / Int24ub,
        "data" / Bytes(this.num8),
    )

Compiled parsing code: (outdated)

::

    def read_bytes(io, count):
        assert count >= 0
        data = io.read(count)
        assert len(data) == count
        return data
    from io import BytesIO
    def restream(data, func):
        return func(BytesIO(data))
    from construct import Container
    from struct import pack, unpack, calcsize
    def parse_struct_1(io, context):
        this = Container()
        this._ = context
        this.num8 = unpack('>B', read_bytes(io, 1))[0]
        this.num24 = int.from_bytes(read_bytes(io, 3), byteorder='big', signed=False)
        this.data = read_bytes(io, this.num8)
        del this._
        return this
    def parseall(io, context):
        this = context
        return parse_struct_1(io, this)
    from construct import Compiled
    compiledschema = Compiled(parseall)

Non-compiled parsing code: (outdated)

::

    def _read_stream(stream, length):
        if length < 0:
            raise StreamError("length must be >= 0", length)
        data = stream.read(length)
        if len(data) != length:
            raise StreamError("could not read enough bytes, expected %d, found %d" % (length, len(data)))
        return data

    class FormatField(Construct):
        def _parse(self, stream, context, path):
            data = _read_stream(stream, self.length)
            try:
                return packer.unpack(self.fmtstr, data)[0]
            except Exception:
                raise FormatFieldError("packer %r error during parsing" % self.fmtstr)

    class BytesInteger(Construct):
        def _parse(self, stream, context, path):
            length = self.length(context) if callable(self.length) else self.length
            data = _read_stream(stream, length)
            if self.swapped:
                data = data[::-1]
            return bytes2integer(data, self.signed)

    class Bytes(Construct):
        def _parse(self, stream, context, path):
            length = self.length(context) if callable(self.length) else self.length
            return _read_stream(stream, length)

    class Renamed(Subconstruct):
        def _parse(self, stream, context, path):
            try:
                path += " -> %s" % (self.name,)
                return self.subcon._parse(stream, context, path)
            except ConstructError as e:
                if "\n" in str(e):
                    raise
                raise e.__class__("%s\n    %s" % (e, path))

    class Struct(Construct):
        def _parse(self, stream, context, path):
            obj = Container()
            context = Container(_ = context)
            for sc in self.subcons:
                try:
                    subobj = sc._parse(stream, context, path)
                    if sc.flagembedded:
                        if subobj is not None:
                            obj.update(subobj)
                            context.update(subobj)
                    else:
                        if sc.name:
                            obj[sc.name] = subobj
                            context[sc.name] = subobj
                except StopIteration:
                    break
            return obj

There are several "shortcuts" that the compiled code does:

Function calls are relatively expensive, so an inlined expression is faster than a function returning the same exact expression. Therefore FormatField compiles into `struct.unpack(..., read_bytes(io, ...))` directly.

Literals like 1 and '>B' are faster than variable (or object field) lookup, or passing function arguments. Therefore each instance of FormatField compiles into a similar expression but with different format-strings and byte-counts inlined, usually literals.

Passing parameters to functions is slower than just referring to variables in same scope. Therefore, for example, compiled Struct creates "this" variable that is accessible to all expressions generated by subcons, as it exists in same scope, but core Struct would call subcon._parse and pass entire context as parameter value, regardless whether that subcon even uses a context (for example FormatField VarInt have no need for a context). Its similar but not exactly the same with "restream" function. The lambda in second parameter is rebounding `io` to a different object (a stream that gets created inside restream function). On the other hand, `this` is not rebounded, it exists in outer scope.

If statement (or conditional ternary operator) with two possible expressions and a condition that could be evaluated at compile-time is slower than just one or the other expression. Therefore, for example, BytesInteger does a lookup to check if field is swapped, but compiled BytesInteger simply inlines 'big' or 'little' literal. Moreover, Struct checks if each subcon has a name and then inserts a value into the context dictionary, but compiled Struct simply has an assignment or not. Also, compiled Struct does not check if subcon is embedded, it either inserts or merges the result of sub-parsing. This shortcut also applies to most constructs, those that accept context lambdas as parameters. Generated classes do need to check if a parameter is a constant or a lambda, because what gets emitted is either something like "1" which is a literal, or something like "this.field" which is an object lookup. Both are valid expressions and evaluate without red tape.

Looping over an iterable is slower than a block of code that accesses each item once. The reason its slower is that each iteration must fetch another item, and also check termination condition. Loop unrolling technique requires the iterable (or list rather) to be known at compile-time, which is the case with Struct and Sequence instances. Therefore, compiled Struct emits one line per subcon, but core Struct loops over its subcons.

Function calls that only defer to another function are only wasting CPU cycles. This relates specifically to Renamed class, which in compiled code emits same code as its subcon. Entire functionality of Renamed class (maintaining path information) is not supported in compiled code, where it would serve as mere subconstruct, just deferring to subcon.

Building two identical dictionaries is slower than building just one. Struct maintains two dictionaries (called obj and context) which differ only by _ key, but compiled Struct maintains only one dictionary and removes the _ key before returning it.

This expressions (not lambdas) are usually expensive to compute but something like "this.field" in a compiled code is merely one object field lookup. Same applies to `len_ obj_ list_` expressions since they share the implementation with `this` expression.

Container is an implementation of so called AttrDict. It captures access to its attributes (field in this.field) and treats it as dictionary key access (this.field becomes this["field"]). However, due to internal CPython drawbacks, capturing attribute access involves some red tape, unlike accessing keys, which is done directly. Therefore compiled Struct emits lines that assign to Container keys, not attributes (outdated example).

TBA: Decompiled instances.
TBA: Caching emitted code.

Empirical evidence
---------------------

The "shortcuts" that are described above are not much, but amount to quite a large portion of actual run-time. In fact, they amount to about half (50%) of entire run-time. Results copied from earlier section.

>>> print(st.benchmark(sampledata))
Timeit measurements:
compiling:         0.00452083740001398872 sec/call
parsing:           0.00062362513400148595 sec/call
parsing compiled:  0.00030551492700033121 sec/call
building:          0.00068562510999981897 sec/call
building compiled: 0.00068885248700098598 sec/call

Comparison with Kaitai Struct
---------------------

TBA: Schemas and bechmarks.
TBA: Tutorials.
